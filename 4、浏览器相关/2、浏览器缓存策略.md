选自：[面经汇总（三）——浏览器和HTTP协议](https://blog.csdn.net/weixin_42729843/article/details/105504469)

@[TOC]
# 缓存策略
## Doctype
< Doctype > 标签申明位于文档的开头，用于告诉浏览器以什么样的方式来渲染页面，有混杂模式和严格模式两种

**混杂模式**向后兼容，模拟老浏览器，防止浏览器版本过旧不兼容页面

**严格模式**是将JS和排版以浏览器最高的标准运行

## 强缓存和协商缓存
服务器上的数据是会有更新的，我们不能一直使用浏览器的本地缓存，这样就只能一直使用旧数据。我们希望当服务器的数据发生更新时，浏览器会请求更新数据，如果服务器上的数据没有更新我们就使用本地数据，这样能节省因网络请求而产生的资源浪费。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210308194202184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)
明确两点：

1、**浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识**

2、**浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210308194235693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)
### 1.强缓存（Cache-control）
>关键词：**不发送请求**
>
>强缓存就是强制缓存，直接读取浏览器缓存。如果在服务器响应的头部字段中设置了**cache-control：max-age=xxx，public/private/immutable**，都有强制缓存，**只要缓存的有效时间（xxx秒）没过，就直接读取浏览器缓存**。如果是用户主动刷新页面，会发起http请求资源，有额外的请求消耗，但是如果设置的是immutable即使用户刷新也直接读取浏览器缓存。 

强缓存有两种策略，对应HTTP1.0，和HTTP1.1。

**Expires策略（HTTP1.0）**
>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
>Expires设置失效时间，精确到时分秒。 不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。

**Cache-control策略（重点关注）**

> Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。
>

>
> http协议头Cache-Control ： 值可以是public、private、no-cache、no-
> store、no-transform、must-revalidate、proxy-revalidate、max-age

### 2. 协商缓存（Last-Modifined）
>关键词：
>**协商缓存：200，304，发送请求
>Last-Modifined -> If-Modified-Since 修改时间
>Etag -> If-None-Match 服务器唯一标识**

 当浏览器请求资源时发现缓存过期，就会去请求服务器进行协商缓存。在之前的服务器响应的头部中，还有两个字段与协商缓存有关

> etag: '5c20abbd-e2e8'
> last-modified: Mon, 24 Dec 2018 09:49:49 GMT

etag是一个文件hash，每个文件唯一。

last-modified是文件最后更新的时间。在协商缓存时浏览器的请求会携带这两个字段，服务器会根据这两个标识对比判断文件是否更新，**如果发生了更新就会返回200状态码，和第一次请求资源一样；如果没有更新就会返回304，调用浏览器缓存**。 
