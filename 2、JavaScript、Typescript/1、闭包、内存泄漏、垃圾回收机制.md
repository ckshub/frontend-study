闭包详见：[闭包的应用和常用的场景](https://blog.csdn.net/abuanden/article/details/114136822)
# 内存泄漏和垃圾回收机制
选自：
[JavaScript 内存泄漏教程](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)
[js常见的内存泄漏](https://www.cnblogs.com/cwxwdm/p/10845376.html)
[JavaScript内存泄露的4种方式及如何避免](https://blog.csdn.net/qappleh/article/details/80337630)
## 一、什么是内存泄漏？
程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。
```c
char * buffer;
buffer = (char*) malloc(42);

// Do something with buffer

free(buffer);
```
上面是 C 语言代码，**malloc**方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。

这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为"**垃圾回收机制**"（garbage collector）。

## 二、垃圾回收机制
最常使用的方法叫做"引用计数"（reference counting）：语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。

>如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。
```js
const arr = [1, 2, 3, 4];
console.log('hello world')
```
上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。

如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。
```js
let arr = [1, 2, 3, 4];
console.log('hello world');
arr = null;
```
上面代码中，arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0，内存就可以释放出来了。

## 三、内存泄漏的识别方法
>经验法则是，**如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。**
### 3.1 浏览器
Chrome 浏览器查看内存占用，按照以下步骤操作。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210304184410661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)
>现在已经改成performance了
>![在这里插入图片描述](https://img-blog.csdnimg.cn/2021030418500585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)

 1. 打开开发者工具，选择performance 面板 
 2. 在顶部的Capture字段里面勾选 Memory 点击左上角的录制按钮。
 3. 在页面上进行各种操作，模拟用户的使用情况。 
 4. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。
>如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20210304185114725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)
>反之，就是内存泄漏了。


## 四、WeakMap
前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。

最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。

ES6 考虑到了这一点，推出了两种新的数据结构：**WeakSet** 和 **WeakMap**。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个"Weak"，表示这是弱引用。

下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。

```js
const wm = new WeakMap();

const element = document.getElementById('example');

wm.set(element, 'some information');
wm.get(element) // "some information"
```

>上面代码中，先新建一个 **Weakmap 实例**。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面**对element的引用**就是弱引用，不会被计入垃圾回收机制。

>也就是说，DOM 节点对象的引用计数**是1**，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。

>基本上，**如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。**

## 五、WeakMap 示例
WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。

但是，如果引用所指向的值占用特别多的内存，就可以通过**process.memoryUsage**方法看出来。

首先，打开 Node 命令行。

```javascript
$ node --expose-gc
```
上面代码中，`--expose-gc`参数表示允许手动执行垃圾回收机制

然后，执行下面的代码。

```javascript
// 手动执行一次垃圾回收，保证获取的内存使用状态准确
> global.gc(); 
undefined

// 查看内存占用的初始状态，heapUsed 为 4M 左右
> process.memoryUsage(); 
{ rss: 21106688,
  heapTotal: 7376896,
  heapUsed: 4153936,
  external: 9059 }

> let wm = new WeakMap();
undefined

> let b = new Object();
undefined

> global.gc();
undefined

// 此时，heapUsed 仍然为 4M 左右
> process.memoryUsage(); 
{ rss: 20537344,
  heapTotal: 9474048,
  heapUsed: 3967272,
  external: 8993 }

// 在 WeakMap 中添加一个键值对，
// 键名为对象 b，键值为一个 5*1024*1024 的数组  
> wm.set(b, new Array(5*1024*1024));
WeakMap {}

// 手动执行一次垃圾回收
> global.gc();
undefined

// 此时，heapUsed 为 45M 左右
> process.memoryUsage(); 
{ rss: 62652416,
  heapTotal: 51437568,
  heapUsed: 45911664,
  external: 8951 }

// 解除对象 b 的引用  
> b = null;
null

// 再次执行垃圾回收
> global.gc();
undefined

// 解除 b 的引用以后，heapUsed 变回 4M 左右
// 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了
> process.memoryUsage(); 
{ rss: 20639744,
  heapTotal: 8425472,
  heapUsed: 3979792,
  external: 8956 }
```
上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。


## 六、常见的内存泄漏
### 1、闭包
闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量。

```javascript
function bindEvent() 
{ 
    var obj=document.createElement("XXX"); 
    obj.onclick=function(){ 
        //Even if it's a empty function 
    } 
}
```

以上代码创建了一个作为 obj 元素事件处理程序**的闭包**，而这个闭包则又创建了一个循环引用，匿名函数中保存了一个对 obj对象的引用，因此无法减少 obj的引用数。只要匿名函数在，obj的引用数至少是 1，因此它所占用的内存就永远无法回收。

**再比如**：

```javascript
    var theThing = null;
    var replaceThing = function () {
        var originalThing = theThing;
        var unused = function () {
            if (originalThing)
                console.log("hi");
        };

        theThing = {
            longStr: new Array(1000000).join('*'),
            someMethod: function () {
                console.log(someMessage);
            }
        };
    };

    setInterval(replaceThing, 1000);
```
>代码片段做了一件事情：每次调用 **replaceThing** ，**theThing** 得到一个包含一个大数组和一个新闭包（**someMethod**）的新对象。

>同时，变量 **unused** 是一个引用 **originalThing** 的**闭包**（先前的 replaceThing 又调用了 theThing ）。
>思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有**同样的父级作用域，作用域是共享的**。
>someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，**尽管 unused从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）**。
>当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，**每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄露。**
- 这里的解决方法：**在 replaceThing 的最后添加 originalThing = null 。**


**解决方法：**
**1、在定义事件处理函数的外部函数中，删除对dom的引用**
《JavaScript权威指南》中介绍过，闭包中，作用域中没用的属性可以删除，以减少内存消耗。
```javascript
function bindEvent() 
{ 
    var obj=document.createElement("XXX"); 
    obj.onclick=function(){ 
        //Even if it's a empty function 
    } 
    obj=null; 
}
```

**2、将事件处理函数定义在外部，解除闭包**
闭包可以维持函数内局部变量，使其得不到释放。
上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包

```javascript
function bindEvent() 
{ 
    var obj=document.createElement("XXX"); 
    obj.onclick=onclickHandler; 
} 
function onclickHandler(){ 
    //do something 
}
```

### 2、意外的全局变量
在 JavaScript 非严格模式中，未定义的变量会自动绑定在全局对象上（window/global），比如：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210304191800886.png)
foo 执行的时候，由于内部变量没有定义，所以相当于 window.bar = 'something'，函数执行完毕，本应该被销毁的变量 bar 却永久的保留在内存中了。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210304191824638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)
> 上面这里应该这么解释：不是箭头函数，普通的函数的this默认指向window。

**解决办法，使用严格模式。**

虽然全局变量上绑定的变量无法被垃圾回收，但是有时需要使用全局变量去存储临时信息，这个时候要格外小心，并在变量使用完毕后设置为 null，以回收内存。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210304192257951.png)

**全局变量注意事项**

尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于 临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，**缓存必须有一个大小上限才有用**。高内存消耗导致缓存突破上限，因为**缓存内容无法被回收。**

### 3、被遗忘的计时器或回调函数

```javascript
var someResource = getData(); 
setInterval(function() { 
    var node = document.getElementById('Node'); 
    if(node) { 
        // 处理 node 和 someResource 
        node.innerHTML = JSON.stringify(someResource)); 
    } 
}, 1000); 
```
此例说明了什么：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，**计时器回调函数仍然没被回收（计时器停止才会被回收）**。同时，someResource 如果存储了大量的数据，也是无法被回收的。

对于观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。如今，即使没有明确移除它们，一旦观察者对象变成不可达，大部分浏览器是可以回收观察者处理函数的。

**观察者代码示例：**

```javascript
var element = document.getElementById('button'); 
function onClick(event) { 
    element.innerHTML = 'text'; 
} 
 
element.addEventListener('click', onClick); 
```

**对象观察者和循环引用注意事项**

**老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄露。**如今，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，**不必非要调用 removeEventListener** 了。

### 4、脱离 DOM 的引用
有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。
```js
var elements = { 
    button: document.getElementById('button'), 
    image: document.getElementById('image'), 
    text: document.getElementById('text') 
}; 
 
function doStuff() { 
    image.src = 'http://some.url/image'; 
    button.click(); 
    console.log(text.innerHTML); 
    // 更多逻辑 
} 
 
function removeButton() { 
    // 按钮是 body 的后代元素 
    document.body.removeChild(document.getElementById('button')); 
 
    // 此时，仍旧存在一个全局的 #button 的引用 
    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 
} 
```