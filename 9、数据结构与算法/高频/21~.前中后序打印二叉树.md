1. 非递归算法

```js
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
function threeOrders(root){
    //非递归算法实现先序遍历二叉树，根左右，所以向数组中push一个元素
    function preOrder(root){
        let res=[],
        stack=[root];
        while(stack.length>0){
            let node=stack.pop();
            res.push(node.val);
            if(node.right){
                stack.push(node.right);
            }
            if(node.left){
                stack.push(node.left);
            }

        }
        return res;
    }
    //非递归算法 实现中序遍历二叉树   首先遍历找到最深层的左子树，
    function inOrder(root){
        let res=[],
            stack=[];
            while(root||stack.length>0){
                while(root){
                    stack.push(root);
                    root=root.left;
                }
                root=stack.pop();
                res.push(root.val);
                root=root.right;
            }
            return res;
    }
    // 非递归算法实现后序遍历二叉树， 和先序遍历二叉树类似，唯一区别是向数组中unshift元素，先push左再push右
    function lastOrder(root){
        let res=[],
        stack=[root];
        while(stack.length>0){
            let node=stack.pop();
            res.unshift(node.val);
            if(node.left){
                stack.push(node.left);
            }
            if(node.right){
                stack.push(node.right);
            }
        }
        return res;
    }

    return [preArray,middleArray,lastArray]
}


/**
 * 
 * @param root TreeNode类 the root of binary tree
 * @return int整型二维数组
 */

module.exports = {
    threeOrders : threeOrders
};
```

2. 递归算法

```js
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */

/**
 * 
 * @param root TreeNode类 the root of binary tree
 * @return int整型二维数组
 */
function threeOrders( root ) {
    const preRes = []
    function preOrder(root) {
        if (root) {
            preRes.push(root.val)
            preOrder(root.left)
            preOrder(root.right)
        }
    }
    const inRes = []
    function inOrder(root) {
        if (root) {
            inOrder(root.left)
            inRes.push(root.val)
            inOrder(root.right)
        }
    }
    const postRes = []
    function postOrder(root) {
        if(root) {
            postOrder(root.left)
            postOrder(root.right)
            postRes.push(root.val)
        }
    }
    // write code here
    preOrder(root)
    inOrder(root)
    postOrder(root)
    return [preRes, inRes, postRes]
}

module.exports = {
    threeOrders : threeOrders
};
```

