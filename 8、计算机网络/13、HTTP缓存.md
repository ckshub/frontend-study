## 一、缓存的规则

> HTTP的缓存属于客户端缓存，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存

#### 1、强制缓存

当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。

#### 2、协商缓存 

客户端会先从**缓存数据库中获取到一个缓存数据的标识**，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。

## 二、服务器是如何判断缓存是否失效

- 与缓存相关的规则信息就包含在相应头中

#### ![img](http://www.361way.com/wp-content/uploads/2017/01/response-headers.png)1. 强缓存

**Expires**：Thu，15 Apr  2010  20：00：00  GMT

由于服务端时间和客户端时间可能有误差，现在都用**Cache-Control**

**Cache-Control**：Cache-Control有很多属性，不同的属性代表的意义也不同。
private：客户端可以缓存
public：客户端和代理服务器都可以缓存
max-age=t：缓存内容将在t秒后失效
no-cache：需要使用协商缓存来验证缓存数据
no-store：所有内容都不会缓存。



#### 2. 协商缓存

1. **Last-Modified**

Last-Modified： 服务器在响应请求时，**会告诉浏览器资源的最后修改时间**。

if-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。（修改则传数据）

if-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改

- 这两个的区别是一个是修改了才下载一个是没修改才下载。
- Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

2. **Etag**

Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。

1. 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
2. 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.

但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。



## 三、缓存的优点 

1. 减少了冗余的数据传递，节省宽带流量
2. 减少了服务器的负担，大大提高了网站性能
3. 加快了客户端加载网页的速度 ------- 这也正是HTTP缓存属于客户端缓存的原因。

## 四、不同刷新的请求执行过程 

1. 浏览器地址栏中写入URL，回车
   浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）
2. F5
   F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since。
3. Ctrl+F5
   告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.

![image-20210321194948412](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321194948412.png)