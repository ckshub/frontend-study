![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzgvMTYzM2VhZDMxNmQwNzcxMw?x-oss-process=image/format,png)

## 一、DNS解析



## 二、HTTP协议格式



## 三、HTTP版本差异

https://blog.csdn.net/weixin_34033624/article/details/91687175

https://www.cnblogs.com/ldq2016/p/9055933.html

0.9get 

1.0 post head 

1.1 长链接  options put delete trace connect     host域 

2.0 多路复用 二进制帧 头部压缩 服务器推送

## 四、HTTP的长链接和短链接的区别

https://www.cnblogs.com/gotodsp/p/6366163.html

## 五、多路复用和长连接的区别

1. 同一个域名访问同一个文件的多个请求都可以复用一个tcp连接（不用像1.0一样 每次请求都需要重新建立连接）
2. **依然存在的问题**：
   1. 多个请求只能被串行处理（**数据基于文本，只能按顺序传输**）；
   2. 访问多个不同的文件依然会建立多个请求。
3. **多路复用**：同一个域名访问多个文件的请求也可以复用一个tcp连接，且多个请求可以被并行处理。
4. **并行实现原理**：http2.0引入二进制数据帧和流的概念（数据帧对每一个数据进行标识，可以不按顺序传输，从而实现并行）

## 六、HTTPS加密过程

1. **客户端主要向服务器提供以下信息，同时索要服务端的证书**
   1. 支持的协议版本号
   2. 一个客户端生成的随机数，稍后用于生成"对话密钥"。
   3. 客户端支持的加密算法
   4. 支持的压缩算法
2. **服务器回应**
   1. 将自己的证书发送给客户端
   2. 私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。
   3. 证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被串改。另外，证书还有个有效期。
   4. 服务端也需要产生一个随机数发送给客户端。客户端和服务端都需要使用这两个随机数来产生Master Secret。
3. **客户端回应** 
   1. 生成一个随机数，如果采用的是RSA加密方式则取出证书中的公钥，生成随机数。该随机数用服务器公钥加密，防止被窃听。
   2. 上面第一项的随机数，是整个握手阶段出现的第三个随机数，它是客户端使用一些加密算法
4. **服务器的最后回应**



1、首先，客户端 A 访问服务器 B ，比如我们用浏览器打开一个网页 [https://www.baidu.com](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.baidu.com) ，这时，浏览器就是客户端 A ，百度的服务器就是服务器 B 了。这时候客户端 A 会生成一个随机数1，把随机数1 、自己支持的 SSL 版本号以及加密算法等这些信息告诉服务器 B 。

2、服务器 B 知道这些信息后，确认一下双方的加密算法，然后服务端也生成一个随机数 B ，并将随机数 B 和 CA 颁发给自己的证书一同返回给客户端 A 。

3、 客户端 A 得到 CA 证书后，会去校验该 CA 证书的有效性，校验方法在上面已经说过了。校验通过后，客户端生成一个随机数3 ，然后用证书中的公钥加密随机数3 并传输给服务端 B 。服务端 B 得到加密后的随机数3，然后利用私钥进行解密，得到真正的随机数3。

4、最后，客户端 A 和服务端 B 都有随机数1、随机数2、随机数3，然后双方利用这三个随机数生成一个对话密钥。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了对称加密，一般用的都是 AES 算法。

5、 客户端 A 通知服务端 B ，指明后面的通讯用对话密钥来完成，同时通知服务器 B 客户端 A 的握手过程结束。

6、服务端 B 通知客户端 A，指明后面的通讯用对话密钥来完成，同时通知客户端 A 服务器 B 的握手过程结束。SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户端 A 和服务器 B 开始使用相同的对话密钥进行数据通讯。

## 七、简单介绍加密原理？

1. 客户端生成随机数A，保存本地，同时发送给服务端，告诉那边我支持的加密算法，并索要证书
2. 服务端生成随机数B，保存随机数A，确定加密算法，并发送证书。
3. 客户端用浏览器自带的证书进行检验是否过期，合格，从证书中取出公钥，生成随机数C，对C用公钥加密。发送给服务端。
4. 服务端对加密后的C用他的私钥解密，得到原来的C。
5. 客户端和服务端用ABC作为下一步通信的密钥，开始对称加密通信。