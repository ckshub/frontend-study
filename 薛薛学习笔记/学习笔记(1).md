

# 前端三剑客基础

## HTML基础

### HTML常用标签

标题（Heading）是通过<h1> - <h6> 标签来定义的。

段落是通过标签 <p> 来定义的。

链接是通过标签 <a> 来定义的。

图像是通过标签 <img> 来定义的。

换行通过 <br>

```html
    <h1>一级标题</h1>
    <h2>二级标题</h2>
    <h3>三级标题</h3>
    <br>
    <p>一个段落。</p>
    <a href="https://www.runoob.com">这是一个链接</a>
    <img loading="lazy" src="status/17.jpg"/>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210312211732244.png" alt="image-20210312211732244" style="zoom: 50%;">

其他标签 [请点击我](https://www.w3school.com.cn/tags/tag_html.asp)

### HTML属性

| 属性  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| class | 为html元素定义一个或多个类名（classname）(类名从样式文件引入) |
| id    | 定义元素的唯一id                                             |
| style | 规定元素的行内样式（inline style）                           |
| title | 描述了元素的额外信息 (作为工具条使用)                        |

建议自己在写代码的时候使用小写属性，使用双引号。



## CSS

### CSS语法

由选择器以及一条或多条声明组成

每条声明又由一个属性或一个值组成

```css
    p {
        color: red;
        text-align: center;
    }
```



### CSS引入的三种方式

**1.行内样式**

最直接最简单的一种，直接对HTML标签使用style=""，例如：

```html
<p style="color:#F00; "></p>
```

缺点：HTML页面不纯净，文件体积大，不利于蜘蛛爬行，后期维护不方便。



**2.内嵌样式**

内嵌样式就是将CSS代码写在<head></head>之间，并且用<style></style>进行声明，例如：

```html
<style type="text/css">
body,div,a,img,p{
    			 margin:0;
   				 padding:0;
   				}
</style>
```

优缺点：页面使用公共CSS代码，也是每个页面都要定义的，如果一个网站有很多页面，每个文件都会变大，后期维护难度也大，如果文件很少，CSS代码也不多，这种样式还是很不错的。



**3.外部样式**

31.链接样式（推荐）

链接样式是使用频率最高，最实用的样式，只需要在<head></head>之间加上<link…/>就可以了，如下：

```html
<link type="text/css" rel="stylesheet" href="style.css" />
```

其中href 为被链接文档的位置

优缺点：实现了页面框架代码与表现CSS代码的完全分离，使得前期制作和后期维护都十分方便



3.2.导入样式（不建议使用）

导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，    成为文件的一部分，类似第二种内嵌样式。

@import在html中使用，如下：

```html
<style type="text/css">
@import url(style.css);
</style>
```


@import在CSS中使用，如下：

```html
@import url(style.css);
```

链接式和导入式的区别：
<link>
    1、属于XHTML
    2、优先加载CSS文件到页面
@import
    1、属于CSS2.1
    2、先加载HTML结构在加载CSS文件。



### 各类选择器

如果你要在HTML元素中设置CSS样式，你需要在元素中设置"id" 和 "class"选择器。

**id选择器**

id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。

HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 "#" 来定义。

以下的样式规则应用于元素属性 id="para1"

```css
#para1 {
    text-align:center;
    color:red;
	}
```

Tips:	ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用



**class选择器**

class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。

class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点"."号显示：

在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。

```css
.center {text-align:center;}
```

你也可以指定特定的HTML元素使用class。

在以下实例中, 所有的 p 元素使用 class="center" 让该元素的文本居中:

```css
p.center {text-align:center;}
```

Tips:	类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。



### 常用属性

#### 字体属性：(font)

大小 font-size:x-large;(特大) xx-small;(极小) 一般中文用不到，只要用数值就可以，单位：PX、PD

样式 font-style:oblique;(偏斜体) italic;(斜体) normal;(正常)

行高 line-height:normal;(正常) 单位：PX、PD、EM

粗细 font-weight:bold;(粗体) lighter;(细体) normal;(正常)

变体font-variant: small-caps;(小型大写字母) normal;(正常)

大小写text-transform: capitalize;(首字母大写) uppercase;(大写) lowercase;(小写) none;(无)

修饰text-decoration: underline;(下划线) overline;(上划线) line-through;(删除线) blink;(闪烁)

#### 背景属性： (background)

色彩background-color:#FFFFFF;

图片background-image:url();

重复background-repeat:no-repeat;

滚动background-attachment:fixed;(固定) scroll;(滚动)

位置background-position:left(水平) top(垂直);

简写方法 background:#000url(..) repeat fixed left top;

#### 区块属性： (Block)

字间距letter-spacing:normal; 数值

对齐text-align:justify;(两端对齐) left;(左对齐) right;(右对齐) center;(居中)

缩进text-indent: 数值px;

垂直对齐vertical-align:baseline;(基线) sub;(下标) super;(下标) top; text-top; middle;bottom; text-bottom;

词间距word-spacing:normal; 数值

空格white-space:pre;(保留) nowrap;(不换行)

显示display:block;(块) inline;(内嵌) list-item;(列表项) run-in;(追加部分) compact;

(紧凑) marker;(标记) table; inline-table;table-raw-group; table-header-group; table-footer-group; table-raw; table-column-group;table-column; table-cell; table-caption;(表格标题)

#### 方框属性： (Box)

width:; height:; float:; clear:both; margin:; padding:; 顺序：上右下左

#### 边框属性： (Border)

border-style: dotted;(点线) dashed;(虚线) solid; double;(双线) groove;(槽线) ridge;(脊状) inset;(凹陷) outset;

border-width:; 边框宽度

border-color:#;

简写方法border：width style color;

#### 列表属性： (List-style)

类型list-style-type: disc;(圆点) circle;(圆圈) square;(方块) decimal;(数字) lower-roman;(小罗码数字) upper-roman;lower-alpha; upper-alpha;

位置list-style-position:outside;(外) inside;

图像list-style-image:url(..);

#### 定位属性： (Position)

Position: absolute; relative; static;

visibility: inherit; visible; hidden;

overflow: visible; hidden; scroll; auto;

clip: rect(12px,auto,12px,auto) (裁切)

#### CSS符号属性：

list-style-type:none; /不编号/

list-style-type:decimal; /阿拉伯数字/

list-style-type:lower-roman; /小写罗马数字/

list-style-type:upper-roman; /大写罗马数字/

list-style-type:lower-alpha; /小写英文字母/

list-style-type:upper-alpha; /大写英文字母/

list-style-type:disc; /实心圆形符号/

list-style-type:circle; /空心圆形符号/

list-style-type:square; /实心方形符号/

list-style-image:url(/dot.gif); /图片式符号/

list-style-position: outside; /凸排/

list-style-position:inside; /缩进/

#### CSS连接属性：

a /所有超链接/

a:link /超链接文字格式/

a:visited /浏览过的链接文字格式/

a:active /按下链接的格式/

a:hover /鼠标转到链接/



### 盒子模型

所有HTML元素可以看作盒子，在CSS中，"box model"这一术语是用来设计和布局时使用。

CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。

盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。

![image-20210312215751195](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210312215751195.png)

- **Margin(外边距)** - 清除边框外的区域，外边距是透明的。
- **Border(边框)** - 围绕在内边距和内容外的边框。
- **Padding(内边距)** - 清除内容周围的区域，内边距是透明的。





### 浮动(Float)

```html
<body>
    <div></div>
    <img src="status/17.jpg" alt="" style="float: right;">
</body>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313184201316.png" alt="image-20210313184201316" style="zoom:50%;" />

若图片之间夹杂文字 不想让文字也进行浮动，可以添加clear 属性指定元素两侧不能出现浮动元素。

```css
.text_line
{
    clear:both;
}
```



### CSS定位

元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法。

#### **static 定位**

HTML 元素的默认值，即没有定位，遵循正常的文档流对象。

静态定位的元素不会受到 top, bottom, left, right影响。



#### **fixed 定位**

元素的位置相对于浏览器窗口是固定位置。

即使窗口是滚动的它也不会移动：

示例：

```html
<style>
    div.fixed {
        position: fixed;
        top: 10rem;
        background-color: blue;
        height: 10rem;
        width: 10rem;
    }
</style>

<body>
    <div class="fixed"></div>
</body>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313190052175.png" alt="image-20210313190052175" style="zoom:50%;" />

Tips: Fixed定位的元素和其他元素重叠。



#### **relative 定位**

相对定位元素的定位是相对其正常位置。

示例：

```html
<style>
    h2.pos_left {
        position: relative;
        left: -20px;
    }

    h2.pos_right {
        position: relative;
        left: 20px;
    }
</style>

<body>
    <h2>这是位于正常位置的标题</h2>
    <h2 class="pos_left">这个标题相对于其正常位置向左移动</h2>
    <h2 class="pos_right">这个标题相对于其正常位置向右移动</h2>
</body>
```

![image-20210313190436057](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313190436057.png)



#### **absolute 定位**

用绝对定位,一个元素可以放在页面上的任何位置。

绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:

```html
<style>
    h2 {
        position: absolute;
        left: 50%;
        top: 150px;
    }
</style>

<body>
    <h2>这是一个绝对定位了的标题</h2>
</body>
```

![image-20210313191210751](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313191210751.png)



#### **sticky 定位**

粘性定位。**position: sticky;** 基于用户的滚动位置来定位。

粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。

它的行为就像 **position:relative;** 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。

元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。

可以用来做导航栏或者通知栏滚动轮播在页面的最上方。

```html
<style>
    div.sticky {
        position: -webkit-sticky;
        position: sticky;
        top: 0;
        padding: 5px;
        background-color: #cae8ca;
        border: 2px solid #4CAF50;
    }
</style>

<body>
    <div class="sticky">我是粘性定位!</div>

    <div style="padding-bottom:2000px">
        <p>滚动我</p>
        <p>来回滚动我</p>
        <p>滚动我</p>
        <p>来回滚动我</p>
        <p>滚动我</p>
        <p>来回滚动我</p>
    </div>
</body>
```

![image-20210313191707032](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313191707032.png)

### CSS布局

#### 两栏布局

##### **一栏固定宽度，一栏自适应**

**一、左float，右margin-left**

```html
	<div class="left">left</div>
	<div class="right">right</div>
```

```css
	body,div{padding: 0 ;margin:0;}
	.left,.right{height: 200px;}
	.left{float: left;width: 200px;background-color:skyblue;}
	.right{margin-left: 200px; background-color: greenyellow;}
```

> 因为块级元素有流体特性，即默认会填充满外部容器，所以只需要设置margin，不需要设置width就可以让content填满剩余的部分。
> 这里margin-left的宽度和左栏宽度一样，是因为左栏浮动，脱离文档流。



**二、左侧float:left; 右侧overflow:hidden；**

```html
	<div class="left">left</div>
	<div class="right">right</div>
```

```css
	body,div{padding: 0 ;margin:0;}
	.left,.right{height: 200px;}
	.left{float: left;width: 200px;background-color:skyblue;}
	.right{overflow:hidden; background-color: greenyellow;}
```

> 

1、position:absolute时

-  这里加一个margin-left便于区分。
-  绝对定位会叠加在float元素上面，并且不会自动填充
-  position不设置宽度时，根据内容确定宽度
-  有一种办法可以解决：给右栏添加`left:200px; right:0;`在方法三有讲
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210303090331766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)

2、display：inline-block时

- 这里加一个margin-left便于区分。
- inline-block 行块盒不会自动填充
- inline-block不设置宽度时，根据内容确定宽度
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210303090146503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)

3、float：right时

- float不设置宽度时，根据内容确定宽度
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210303090534309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FidWFuZGVu,size_16,color_FFFFFF,t_70)

4、overflow为其他情况时

- auto、hidden、overplay都可以实现
- scroll时会出现滑动条，其他都不行



**三、利用绝对定位**

```html
	<div class="wrap">
		<div class="left">left</div>
		<div class="right">right</div>
	</div>
```

```css
.wrap{position : absolute; }
.left{ width: 200px; }
.right{ position: absolute; top: 0; left: 200px; right: 0}
```

> 通过设置`right:0；`来限制右边块级元素的宽度;`left: 200px;`来自适应宽度。

**四、利用弹性布局**

```html
	<div class="wrap">
		<div class="left">left</div>
		<div class="right">right</div>
	</div>
```

```css
    body,div{padding: 0 ;margin:0;}
	.wrap{display: flex;}
	.left,.right{height: 200px;}
	.left{width: 200px;background-color:skyblue;}
	.right{flex: 1; background-color: greenyellow;}
```



##### 一栏不定宽，一栏自适应

一、左侧float:left; 右侧overflow:hidden；

不再赘述，原理同上面的

二、利用弹性布局

```css
        body,div{padding: 0 ;margin:0;}
		.wrap{display:flex;}
		.left,.right{height: 200px;padding: 10px;}
		.left{background-color:skyblue;}
		.right{flex:1;background-color: yellow;}
```

和上面定宽一样，通过flex：1

> 综上所述，使用BFC和flex布局通用性高

#### 三栏布局

##### 一. 浮动布局

```css
	 .layout.float .left{
        float:left;
        width:300px;
        background: red;
      }
      .layout.float .center{
        background: yellow;
      }
      .layout.float .right{
        float:right;
        width:300px;
        background: blue;
      }
```

> 浮动布局是有局限性的，浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。
> 浮动布局的优点就是比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的。

##### 二、绝对定位布局

```css
.left{
    position: absolute;
    left: 0;
    width: 300px;
    background-color: red;
}
.center{
    position: absolute;
    left: 300px;
    right: 300px;
    background-color: blue;
}
.right{
    position: absolute;
    right: 0;
    width: 300px;
    background-color: #3A2CAC;
}
```

> 我们需要选择给 左 中 右 都使用 absolute 绝对定位
>
> 绝对定位布局优点，很快捷，设置很方便，而且也不容易出问题，你可以很快的就能想出这种布局方式。
> 缺点就是，绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的。

### 居中方法

##### **元素居中对齐**

要水平居中对齐一个元素(如 <div>), 可以使用 **margin: auto;**。

设置到元素的宽度将防止它溢出到容器的边缘。

元素通过指定宽度，并将两边的空外边距平均分配：

```html
<style>
    .center {
        margin:auto;
        width: 60%;
        border: 3px solid #73AD21;
        padding: 10px;
    }
    </style>

<body>
    <div class="center">我居中对齐</div>
</body>
```

![image-20210313194646935](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313194646935.png)



##### 文本居中对齐

如果仅仅是为了文本在元素内居中对齐，可以使用 **text-align: center;**

```css
    .center {
        text-align: center;
        width: 60%;
        border: 3px solid #73AD21;
        padding: 10px;
    }
```

![image-20210313194824882](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313194824882.png)

##### 图片居中对齐

要让图片居中对齐, 可以使用 **margin: auto;** 并将它放到 **块** **(block)** 元素中:

```css
img {
    display: block;
    margin: auto;
}
```



##### 左右对齐

**1.使用绝对定位（position:absolute）**

```css
.right {
    position: absolute;
    right: 0px;
    width: 300px;
    border: 3px solid #73AD21;
    padding: 10px;
}
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313195610204.png" alt="image-20210313195610204" style="zoom:50%;" />



**2.使用浮动（float）**

```html
<style>
.right {
    float: right;
    width: 300px;
    border: 3px solid #73AD21;
    padding: 10px;
}
</style>
</head>
<body>

<div class="right">
  <p>我用float右对齐了</p>
</div>
```

![image-20210313195741719](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313195741719.png)



##### 垂直居中

**1.使用 padding**

```
.center {
    padding: 70px 0;
    border: 3px solid green;
    text-align: center;
}
```

如果要水平和垂直都居中，可以使用 **padding** 和 **text-align: center**:



**2.使用 line-height**

```css
.center {
    line-height: 200px;
    height: 200px;
    border: 3px solid green;
    text-align: center;
}
```

这里 **line-height** 要等于 **height** ,如果有多行文字，需要添加以下样式

```css
.center p {
    line-height: 1.5;
    display: inline-block;
    vertical-align: middle;
}
```



**3.使用 position 和 transform**

```html
<style>
.center { 
    height: 200px;
    position: relative;
    border: 3px solid green; 
}

.center p {
    margin: 0;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
</style>
</head>
<body>

<div class="center">
  <p>我是水平和垂直居中的。</p>
</div>

</body>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313200550242.png" alt="image-20210313200550242" style="zoom:50%;" />

## JavaScript基础

### HTML 引入 JS 的三种方式

#### 行内式

```html
	<!-- 行内js -->
	<button onclick="alert('别点我！')">按钮1</button>
	<button onclick="alert('听到没，别点我！')">按钮2</button>
```

#### 页内式

```html
	<!-- 页内js -->
	<script type="text/javascript">
		alert('我是页内JS的写法===');
	</script>
```

#### 外链式

```html
	<!-- 引入外部的js -->
	<script type="text/javascript" src="js/index.js"></script>
```



### JS 基础语法

```
var x, y;	// 如何声明变量
x = 7; y = 8;	// 如何赋值
z = x + y;	// 如何计算值
```



##### JavaScript 显示数据

JavaScript 可以通过不同的方式来输出数据：

- 使用 **window.alert()** 弹出警告框。
- 使用 **document.write()** 方法将内容写到 HTML 文档中。
- 使用 **innerHTML** 写入到 HTML 元素。
- 使用 **console.log()** 写入到浏览器的控制台。



##### JavaScript 注释

并非所有 JavaScript 语句都被“执行”。

双斜杠 // 或 /* 与 **/* 之间的代码被视为*注释*。

注释会被忽略，不会被执行：

```
var x = 7;   // 会执行

// var x = 8;   不会执行
```



##### JavaScript 标识符

标识符是名称。

在 JavaScript 中，标识符用于命名变量（以及关键词、函数和标签）。

在大多数编程语言中，合法名称的规则大多相同。

在 JavaScript 中，首字符必须是字母、下划线（-）或美元符号（$）。

连串的字符可以是字母、数字、下划线或美元符号。

**提示：**数值不可以作为首字符。这样，JavaScript 就能轻松区分标识符和数值。



##### JavaScript 对大小写敏感

所有 JavaScript 标识符*对大小写敏感*。

变量 lastName 和 lastname，是两个不同的变量。

```
lastName = "Gates";
lastname = "Jobs";
```



### 数据类型

**字符串** 

```
var answer="He is called 'Johnny'";
```

**数字**

```
var x1=34.00;      //使用小数点来写
var x2=34;         //不使用小数点来写
var y=123e5;      // 12300000
var z=123e-5;     // 0.00123
```

**布尔**

```
var x=true;
var y=false;
```

**数组**

```
var cars=["Saab","Volvo","BMW"];
```

**对象**

```
var person={
firstname : "John",
lastname  : "Doe",
id        :  5566
};
```

**Undefined 和 Null**

Undefined 这个值表示变量不含有值。

可以通过将变量的值设置为 null 来清空变量。

```
cars=null;
person=null;
```



### 对象

JavaScript 对象是拥有属性和方法的数据。

对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 **name:value** 对呈现。

```js
var car = {name:"Fiat", model:500, color:"white"};
```

在以上实例中，3 个值 ("Fiat", 500, "white") 赋予变量 car。 JavaScript 对象是变量的容器。

**访问对象属性**

car.name; 或者 car["name"];

**对象方法**

```js
var person = {
    firstName: "John",
    lastName : "Doe",
    id : 5566,
    fullName : function() 
	{
       return this.firstName + " " + this.lastName;
    }
};
```

对象的方法定义了一个函数，并作为对象的属性存储。

对象方法通过添加 () 调用 (作为一个函数)。



### 函数

**函数定义**

函数就是包裹在花括号中的代码块，前面使用了关键词 function：

```js
function *functionname*()
{
  *// 执行代码*
}
```

当调用该函数时，会执行函数内的代码。

可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。

**带参数的函数**

```html
<p>点击这个按钮，来调用带参数的函数。</p>
<button onclick="myFunction('Harry Potter','Wizard')">点击这里</button>
<script>
function myFunction(name,job){
    alert("Welcome " + name + ", the " + job);
}
</script>
```

**带返回值的函数**

```js
function myFunction(a,b)
{
    return a*b;
}
```



### 作用域

在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。

#### 局部作用域

变量在函数内声明，变量为局部作用域。

局部变量：只能在函数内部访问。

```js
// 此处不能调用 carName 变量
function myFunction() {
    var carName = "Volvo";
    // 函数内可调用 carName 变量
}
```

因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。

局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。



#### 全局变量

变量在函数外定义，即为全局变量。

全局变量有 **全局作用域**: 网页中所有脚本和函数均可使用。

```js
var carName = " Volvo";
 
// 此处可调用 carName 变量
function myFunction() {
    // 函数内可调用 carName 变量
}
```



### DOM(文档对象模型)

#### 查找

通常，通过 JavaScript，您需要操作 HTML 元素。

为了做到这件事情，您必须首先找到该元素。有三种方法来做这件事：

- **通过 id 找到 HTML 元素** (getElementById)

```html
<body>
<p id="intro">你好世界!</p>
<script>
	x=document.getElementById("intro");
	document.write("<p>文本来自 id 为 intro 段落: " + x.innerHTML + "</p>");
</script>
</body>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313211336445.png" alt="image-20210313211336445" style="zoom: 67%;" />

- **通过标签名找到 HTML 元素 **(getElementsByTagName)

本例查找 id="main" 的元素，然后查找 id="main" 元素中的所有 <p> 元素：(要先查找id再从后查找标签名)

```html
<body>
	<p>你好世界!</p>
	<div id="main">
		<p> DOM 是非常有用的。</p>
		<p>该实例展示了  <b>getElementsByTagName</b> 方法</p>
	</div>
<script>
	var x=document.getElementById("main");
	var y=x.getElementsByTagName("p");
	document.write('id="main"元素中的第一个段落为：' + y[0].innerHTML);
</script>
</body>
```

![image-20210313211805402](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313211805402.png)



- **通过类名找到 HTML 元素** (getElementsByClassName)

```html
<body>
	<p class="intro">你好世界!</p>
<script>
	x=document.getElementsByClassName("intro");
	document.write("<p>文本来自 class 为 intro 段落: " + x[0].innerHTML + "</p>");
</script>
</body>
```

![image-20210313212042990](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210313212042990.png)



#### 改变HTML

##### 改变输出流

```html
<script>
	document.write(Date());
</script>
```



##### 改变 HTML 内容

改变 p 元素

```html
<body>
	<p id="p1">Hello World!</p>
<script>
	document.getElementById("p1").innerHTML="新文本!";
</script>
</body>
```

改变 h 元素

```html
<body>
	<h1 id="header">Old Header</h1>
<script>
	var element=document.getElementById("header");
	element.innerHTML="新标题";
</script>
</body>
```



##### 改变 HTML 属性

```html
<body>
	<img id="image" src="smiley.gif">
<script>
	document.getElementById("image").src="landscape.jpg";
</script>
</body>
```



#### 改变CSS

如需改变 HTML 元素的样式，请使用这个语法：

document.getElementById(*id*).style.*property*=*新样式*

```html
<body> 
	<p id="p1">Hello World!</p>
	<p id="p2">Hello World!</p>
<script>
	document.getElementById("p2").style.color="blue";
	document.getElementById("p2").style.fontFamily="Arial";
	document.getElementById("p2").style.fontSize="larger";
</script>
</body>
```



**点击按钮**

```html
<body>
	<h1 id="id1">我的标题 1</h1>
	<button type="button"
	onclick="document.getElementById('id1').style.color='red'">
	点我!</button>
</body>
```



#### HTML事件

- 当用户点击鼠标时

```html
<h1 onclick="this.innerHTML='Ooops!'">点击文本!</h1>

or 

<script>
	function changetext(id)
	{
	    id.innerHTML="Ooops!";
	}
</script>
</head>
<body>
	<h1 onclick="changetext(this)">点击文本!</h1>
</body>

or

<body>
	<button id="myBtn">点这里</button>
<script>
	document.getElementById("myBtn").onclick=function(){displayDate()};
	function displayDate(){
	document.getElementById("demo").innerHTML=Date();
	}
</script>
	<p id="demo"></p>
</body>
```



- 当用户进入页面时 (离开时onload 为 onunload )

```html
<body onload="checkCookies()">
<script>
	function checkCookies(){
		if (navigator.cookieEnabled==true){
			alert("Cookies 可用")
		}
		else{
			alert("Cookies 不可用")
		}
	}
</script>
	<p>弹窗-提示浏览器 cookie 是否可用。</p>
</body>
```



- 当鼠标移动到元素上和离开元素时

  ```html
  <body>
  
  <div onmouseover="mOver(this)" onmouseout="mOut(this)">Mouse Over Me</div>
  <script>
  function mOver(obj){
  	obj.innerHTML="Thank You"
  }
  function mOut(obj){
  	obj.innerHTML="Mouse Over Me"
  }
  </script>
  
  </body>
  ```



- 当用户点住元素和释放元素时

  **onmousedown、onmouseup**

  onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。

#### EventListener (事件监听器)

*element*.addEventListener(*event, function, useCapture*);

第一个参数是事件的类型 (如 "click" 或 "mousedown").

第二个参数是事件触发后调用的函数。

第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。

示例：

```html
<body>

<p>实例使用 addEventListener() 方法在同一个按钮中添加多个事件。</p>
<button id="myBtn">点我</button>
<p id="demo"></p>
<script>
var x = document.getElementById("myBtn");
x.addEventListener("mouseover", myFunction);
x.addEventListener("click", mySecondFunction);
x.addEventListener("mouseout", myThirdFunction);
function myFunction() {
    document.getElementById("demo").innerHTML += "Moused over!<br>"
}
function mySecondFunction() {
    document.getElementById("demo").innerHTML += "Clicked!<br>"
}
function myThirdFunction() {
    document.getElementById("demo").innerHTML += "Moused out!<br>"
}
</script>

</body>
```

**向windows添加句柄**

```html
<body>

<p>实例在 window 对象中使用 addEventListener() 方法。</p>
<p>尝试重置浏览器的窗口触发 "resize" 事件句柄。</p>
<p id="demo"></p>
<script>
window.addEventListener("resize", function(){
    document.getElementById("demo").innerHTML = Math.random();
});
</script>

</body>
```



### BOM(浏览器对象模型)

#### Window 尺寸

有三种方法能够确定浏览器窗口的尺寸。

对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：**（推荐）**

- window.innerHeight - 浏览器窗口的内部高度(包括滚动条)
- window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)

对于 Internet Explorer 8、7、6、5：

- document.documentElement.clientHeight
- document.documentElement.clientWidth

或者

- document.body.clientHeight
- document.body.clientWidth



#### 其他 Window 方法

一些其他方法：

- window.open() - 打开新窗口
- window.close() - 关闭当前窗口
- window.moveTo() - 移动当前窗口
- window.resizeTo() - 调整当前窗口的尺寸



#### Window Screen

- screen.availWidth - 属性返回访问者屏幕的宽度，以像素计
- screen.availHeight - 属性返回访问者屏幕的高度，以像素计



#### Window Location

- location.hostname 返回 web 主机的域名
- location.pathname 返回当前页面的路径和文件名
- location.port 返回 web 主机的端口 （80 或 443）
- location.protocol 返回所使用的 web 协议（http: 或 https:）
- location.href 属性返回当前页面的 URL
- location.pathname 属性返回 URL 的路径名。
- location.assign() 方法加载新的文档。(可以后退返回上个页面)
- location.replace() 方法加载新的文档。(不可退回)



#### Window History

- history.back() - 与在浏览器点击后退按钮相同
- history.forward() - 与在浏览器中点击向前按钮相同
- history.go() - 后面的参数为-1则退回上个页面 ，为0则刷新页面，为1则进入下一个页面 以此类推



#### Window Navigator

**window.navigator** 对象在编写时可不使用 window 这个前缀。

```html
<script>
txt = "<p>浏览器代号: " + navigator.appCodeName + "</p>";
txt+= "<p>浏览器名称: " + navigator.appName + "</p>";
txt+= "<p>浏览器版本: " + navigator.appVersion + "</p>";
txt+= "<p>启用Cookies: " + navigator.cookieEnabled + "</p>";
txt+= "<p>硬件平台: " + navigator.platform + "</p>";
txt+= "<p>用户代理: " + navigator.userAgent + "</p>";
txt+= "<p>用户代理语言: " + navigator.language + "</p>";
document.getElementById("example").innerHTML=txt;
</script>
```

属性详情见（https://www.w3school.com.cn/js/js_window_navigator.asp）



#### 弹窗

可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框。

- alert() 警告框
- confirm() 确认框

```html
<script>
function myFunction(){
	var x;
	var r=confirm("按下按钮!");
	if (r==true){
		x="你按下了\"确定\"按钮!";
	}
	else{
		x="你按下了\"取消\"按钮!";
	}
	document.getElementById("demo").innerHTML=x;
}
</script>
```

![image-20210314190110469](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314190110469.png)



- prompt() 提示框

```html
<script>
function myFunction(){
	var x;
	var person=prompt("请输入你的名字","Harry Potter");
	if (person!=null && person!=""){
	    x="你好 " + person + "! 今天感觉如何?";
	    document.getElementById("demo").innerHTML=x;
	}
}
</script>
```

![image-20210314190841596](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314190841596.png)



弹窗使用 反斜杠 + "n"(\n) 来设置换行。

```js
alert("Hello\nHow are you?");
```



#### JavaScript 计时事件

通过使用 JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。

在 JavaScritp 中使用计时事件是很容易的，两个关键方法是:

- **setInterval**() - 间隔指定的毫秒数不停地执行指定的代码。

```js
var myVar=setInterval(function(){myTimer()},1000);
 
function myTimer()
{
    var d=new Date();
    var t=d.toLocaleTimeString();
    document.getElementById("demo").innerHTML=t;
}
```

**clearInterval**() 方法用于停止 setInterval() 方法执行的函数代码。

```html
<p id="demo"></p>
<button onclick="myStopFunction()">停止</button>
<script>
var myVar=setInterval(function(){myTimer()},1000);
function myTimer(){
    var d=new Date();
    var t=d.toLocaleTimeString();
    document.getElementById("demo").innerHTML=t;
}
function myStopFunction(){
    clearInterval(myVar);
}
</script
```



- setTimeout() - 在指定的毫秒数后执行指定代码。

  ```js
  setTimeout(function(){alert("Hello")},3000);
  ```

  **clearTimeout()** 方法用于停止执行setTimeout()方法的函数代码。

  ```js
  var myVar;
   
  function myFunction()
  {
      myVar=setTimeout(function(){alert("Hello")},3000);
  }
   
  function myStopFunction()
  {
      clearTimeout(myVar);
  }
  ```



### Cookie

Cookie 是一些数据, 存储于你电脑上的文本文件中。

当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。

Cookie 的作用就是用于解决 "如何记录客户端的用户信息":

- 当用户访问 web 页面时，他的名字可以记录在 cookie 中。
- 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。

#### 设置 cookie 值的函数

```js
function setCookie(cname,cvalue,exdays)
{
  var d = new Date();
  d.setTime(d.getTime()+(exdays*24*60*60*1000));
  var expires = "expires="+d.toGMTString();
  document.cookie = cname + "=" + cvalue + "; " + expires;
}
```

以上的函数参数中，cookie 的名称为 cname，cookie 的值为 cvalue，并设置了 cookie 的过期时间 expires。

该函数设置了 cookie 名、cookie 值、cookie过期时间。



#### 获取 cookie 值的函数

```js
function getCookie(cname)
{
  var name = cname + "=";
  var ca = document.cookie.split(';');
  for(var i=0; i<ca.length; i++) 
  {
    var c = ca[i].trim();
    if (c.indexOf(name)==0) return c.substring(name.length,c.length);
  }
  return "";
}
```

cookie 名的参数为 cname。

创建一个文本变量用于检索指定 cookie :cname + "="。

使用分号来分割 document.cookie 字符串，并将分割后的字符串数组赋值给 ca (ca = document.cookie.split(';'))。

循环 ca 数组 (i=0;i<ca.length;i++)，然后读取数组中的每个值，并去除前后空格 (c=ca[i].trim())。

如果找到 cookie(c.indexOf(name) == 0)，返回 cookie 的值 (c.substring(name.length,c.length)。

如果没有找到 cookie, 返回 ""。



#### 检测 cookie 值的函数

最后，我们可以创建一个检测 cookie 是否创建的函数。

如果设置了 cookie，将显示一个问候信息。

如果没有设置 cookie，将会显示一个弹窗用于询问访问者的名字，并调用 setCookie 函数将访问者的名字存储 365 天：

```js
function checkCookie()
{
  var username=getCookie("username");
  if (username!="")
  {
    alert("Welcome again " + username);
  }
  else 
  {
    username = prompt("Please enter your name:","");
    if (username!="" && username!=null)
    {
      setCookie("username",username,365);
    }
  }
}
```



# 前端三剑客高级

## HTML5

### HTML5 新语义标签

| 标签                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [article](https://www.runoob.com/tags/tag-article.html)      | 定义页面独立的内容区域。                                     |
| [aside](https://www.runoob.com/tags/tag-aside.html)          | 定义页面的侧边栏内容。                                       |
| [bdi](https://www.runoob.com/tags/tag-bdi.html)              | 允许您设置一段文本，使其脱离其父元素的文本方向设置。         |
| [command](https://www.runoob.com/tags/tag-command.html)      | 定义命令按钮，比如单选按钮、复选框或按钮                     |
| [details](https://www.runoob.com/tags/tag-details.html)      | 用于描述文档或文档某个部分的细节                             |
| [dialog](https://www.runoob.com/tags/tag-dialog.html)        | 定义对话框，比如提示框                                       |
| [summary](https://www.runoob.com/tags/tag-summary.html)      | 标签包含 details 元素的标题                                  |
| [figure](https://www.runoob.com/tags/tag-figure.html)        | 规定独立的流内容（图像、图表、照片、代码等等）。             |
| [figcaption](https://www.runoob.com/tags/tag-figcaption.html) | 定义 <figure> 元素的标题                                     |
| [footer](https://www.runoob.com/tags/tag-footer.html)        | 定义 section 或 document 的页脚。                            |
| [header](https://www.runoob.com/tags/tag-header.html)        | 定义了文档的头部区域                                         |
| [mark](https://www.runoob.com/tags/tag-mark.html)            | 定义带有记号的文本。                                         |
| [meter](https://www.runoob.com/tags/tag-meter.html)          | 定义度量衡。仅用于已知最大和最小值的度量。                   |
| [nav](https://www.runoob.com/tags/tag-nav.html)              | 定义导航链接的部分。                                         |
| [progress](https://www.runoob.com/tags/tag-progress.html)    | 定义任何类型的任务的进度。                                   |
| [ruby](https://www.runoob.com/tags/tag-ruby.html)            | 定义 ruby 注释（中文注音或字符）。                           |
| [rt](https://www.runoob.com/tags/tag-rt.html)                | 定义字符（中文注音或字符）的解释或发音。                     |
| [rp](https://www.runoob.com/tags/tag-rp.html)                | 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 |
| [section](https://www.runoob.com/tags/tag-section.html)      | 定义文档中的节（section、区段）。                            |
| [time](https://www.runoob.com/tags/tag-time.html)            | 定义日期或时间。                                             |
| [wbr](https://www.runoob.com/tags/tag-wbr.html)              | 规定在文本中的何处适合添加换行符。                           |

此些都为新H5的语义标签，需要使用时点击超链接查看用法和属性。

[canvas](https://www.runoob.com/tags/tag-canvas.html) (画布)

| 属性   | 值       | 描述             |
| :----- | :------- | :--------------- |
| height | *pixels* | 规定画布的高度。 |
| width  | *pixels* | 规定画布的宽度。 |

```html
<body>

<canvas id="myCanvas">你的浏览器不支持 HTML5 canvas 标签。</canvas>

<script>
var c=document.getElementById('myCanvas');
var ctx=c.getContext('2d');
ctx.fillStyle='#FF0000';
ctx.fillRect(0,0,80,100);
</script>

</body>
```

![image-20210314094652076](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314094652076.png)、





### HTML5 表单

| 标签                                                      | 描述                                                         |
| :-------------------------------------------------------- | :----------------------------------------------------------- |
| [datalist](https://www.runoob.com/tags/tag-datalist.html) | <input>标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 |
| [keygen](https://www.runoob.com/tags/tag-keygen.html)     | <keygen> 标签规定用于表单的密钥对生成器字段。                |
| [output](https://www.runoob.com/tags/tag-output.html)     | <output> 标签定义不同类型的输出，比如脚本的输出。            |

#### datalist

**datalist** 元素规定输入域的选项列表。

**datalist** 属性规定 **form** 或 **input** 域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项：

使用 **input** 元素的列表属性与 **datalist** 元素绑定.

```html
<input list="browsers">
 
<datalist id="browsers">
  <option value="Internet Explorer">
  <option value="Firefox">
  <option value="Chrome">
  <option value="Opera">
  <option value="Safari">
</datalist>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314100637489.png" alt="image-20210314100637489" style="zoom: 67%;" />



#### keygen

**keygen** 元素的作用是提供一种验证用户的可靠方法。

**keygen** 标签规定用于表单的密钥对生成器字段。

当提交表单时，会生成两个键，一个是私钥，一个公钥。

私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。

```html
<form action="demo_keygen.asp" method="get">
用户名: <input type="text" name="usr_name">
加密: <keygen name="security">
<input type="submit">
</form>
```



#### output

<output> 元素用于不同类型的输出，比如计算或脚本输出：

```html
<body>

<form oninput="x.value=parseInt(a.value)+parseInt(b.value)">0
<input type="number" id="a" value="50">
+<input type="number" id="b" value="50">
=<output name="x" for="a b"></output>
</form>

</body>
```

![image-20210314101442205](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314101442205.png)





### 音频和视频

| 标签                                                  | 描述                              |
| :---------------------------------------------------- | :-------------------------------- |
| [audio](https://www.runoob.com/tags/tag-audio.html)   | 定义音频内容                      |
| [video](https://www.runoob.com/tags/tag-video.html)   | 定义视频（video 或者 movie）      |
| [source](https://www.runoob.com/tags/tag-source.html) | 定义多媒体资源 <video> 和 <audio> |
| [embed](https://www.runoob.com/tags/tag-embed.html)   | 定义嵌入的内容，比如插件。        |

详细用法及属性点击超链接查询

示例：

```html
<body>

<audio controls>
  <source src="horse.mp3" >
</audio>

</body>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314095628879.png" alt="image-20210314095628879" style="zoom:67%;" />

```html
<body>

<embed type="video/webm" src="movie.mp4" width="400" height="300">

</body>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314095646132.png" alt="image-20210314095646132" style="zoom:50%;" />



### 本地存储

![img](https://www.runoob.com/wp-content/uploads/2019/04/3793073884-56950753e65db_articlex.png)

#### **localStorage**

用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。

示例如下：

- 使用 key="sitename" 和 value="菜鸟教程" 创建一个 localStorage 键/值对。
- 检索键值为"sitename" 的值然后将数据插入 id="result"的元素中。

```html
<body>

<div id="result"></div>
<script>
  localStorage.sitename="小A";
  document.getElementById("result").innerHTML="这里是：" + localStorage.sitename;
</script>

</body>
```

不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：

- 保存数据：localStorage.setItem(key,value);
- 读取数据：localStorage.getItem(key);
- 删除单个数据：localStorage.removeItem(key);
- 删除所有数据：localStorage.clear();
- 得到某个索引的key：localStorage.key(index);



#### sessionStorage

用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。

sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。

如何创建并访问一个 sessionStorage：

```html
<script>
function clickCounter()
{
	if(typeof(Storage)!=="undefined")
	{
		if (sessionStorage.clickcount)
		{
			sessionStorage.clickcount=Number(sessionStorage.clickcount)+1;
		}
		else
		{
			sessionStorage.clickcount=1;
		}
		document.getElementById("result").innerHTML="在这个会话中你已经点击了该按钮 " + sessionStorage.clickcount + " 次 ";
	}
	else
	{
		document.getElementById("result").innerHTML="抱歉，您的浏览器不支持 web 存储";
	}
}
</script>
```

用法和localStorage类似，typeof(Storage) 是为了检查浏览器是否兼容web存储 Number() 是将字符串等转换为数字类型。



### 离线

HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。

应用程序缓存为应用带来三个优势：

1. 离线浏览 - 用户可在应用离线时使用它们
2. 速度 - 已缓存资源加载得更快
3. 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。

**Cache Manifest 基础**

如需启用应用程序缓存，请在文档的<html> 标签中包含 manifest 属性：

```html
<!DOCTYPE HTML>
<html manifest="demo.appcache">
...
</html>
```

每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。

manifest 文件的建议的文件扩展名是：".appcache"。

**Manifest 文件**

manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。

manifest 文件可分为三个部分：

- *CACHE MANIFEST* - 在此标题下列出的文件将在首次下载后进行缓存
- *NETWORK* - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
- *FALLBACK* - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）

**实例 - 完整的 Manifest 文件**

```
CACHE MANIFEST
\# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js

NETWORK:
login.php

FALLBACK:
/html/ /offline.html
```



## CSS3

### 2D转换

#### rotate

rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。

```html
<style> 
div
{
	width:200px;
	height:100px;
	background-color:yellow;
	/* Rotate div */
	transform:rotate(90deg);
	-ms-transform:rotate(90deg); /* IE 9 */
	-webkit-transform:rotate(5deg); /* Safari and Chrome */
}
</style>
</head>
<body>

<div>Hello</div>

</body>
```

![image-20210314134909304](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314134909304.png)

#### translate

translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。

```html
<style> 
div
{
	width:100px;
	height:75px;
	background-color:red;
	border:1px solid black;
}
div#div2
{
	transform:translate(50px,100px);
	-ms-transform:translate(50px,100px); /* IE 9 */
	-webkit-transform:translate(50px,100px); /* Safari and Chrome */
}
</style>
</head>
<body>

<div>Hello. This is a DIV element.</div>

<div id="div2">Hello. This is a DIV element.</div>

</body>
```

![image-20210314135216475](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314135216475.png)



#### scale

scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：

```html
<style>
div {
    margin: 150px;
    width: 200px;
    height: 100px;
    background-color: yellow;
    border: 1px solid black;
    border: 1px solid black;
    transform: scale(2,3); /* 标准语法 */
}
</style>
</head>
<body>

<p>scale() 方法用于增加或缩小元素的大小。</p>

<div>
div 元素的宽度是原始大小的两倍，高度是原始大小的三倍。
</div>

</body>
```

![image-20210314135333690](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314135333690.png)



#### skew

语法

```
transform:skew(<angle> [,<angle>]);
```

包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。

- skewX(<angle>);表示只在X轴(水平方向)倾斜。
- skewY(<angle>);表示只在Y轴(垂直方向)倾斜。

```html
<style> 
div
{
	width:100px;
	height:75px;
	background-color:red;
	border:1px solid black;
}
div#div2
{
	transform:skew(30deg,20deg);
	-ms-transform:skew(30deg,20deg); /* IE 9 */
	-webkit-transform:skew(30deg,20deg); /* Safari and Chrome */
}
</style>
</head>
<body>

<div>Hello. This is a DIV element.</div>

<div id="div2">Hello. This is a DIV element.</div>

</body>
```

![image-20210314135610142](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314135610142.png)

#### matrix

matrix()方法和2D变换方法合并成一个。

matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。

六个参数分别代表 水平缩放 ，水平倾斜，垂直倾斜，垂直缩放，水平移动，垂直移动



### 3D转换

- rotateX()

```html
<style> 
div
{
	width:100px;
	height:75px;
	background-color:red;
	border:1px solid black;
}
div#div2
{
	transform:rotateX(120deg);
	-webkit-transform:rotateX(120deg); /* Safari and Chrome */
}
</style>
</head>
<body>

<p><b>注意:</b> Internet Explorer 9 (以及更早版本的浏览器) 和 Opera 不支持 rotateX 方法.</p>

<div>Hello. This is a DIV element.</div>

<div id="div2">Hello. This is a DIV element.</div>

</body>
```

![image-20210314140222355](C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314140222355.png)

- rotateY()

  方法与 rotateX 类似 ，不再举例



### 过渡

CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。

要实现这一点，必须规定两项内容：

- 指定要添加效果的CSS属性
- 指定效果的持续时间。(不添加时间没有效果，默认为0)

```html
<style> 
div {
    width: 100px;
    height: 100px;
    background: red;
    -webkit-transition: width 2s, height 2s, -webkit-transform 2s; /* For Safari 3.1 to 6.0 */
    transition: width 2s, height 2s, transform 2s;
}

div:hover {
    width: 200px;
    height: 200px;
    -webkit-transform: rotate(180deg); /* Chrome, Safari, Opera */
    transform: rotate(180deg);
}
</style>
```

可以分别设置多个样式变换过渡的时间。

下表列出了所有的过渡属性:

| 属性                                                         | 描述                                         | CSS  |
| :----------------------------------------------------------- | :------------------------------------------- | :--- |
| [transition](https://www.runoob.com/cssref/css3-pr-transition.html) | 简写属性，用于在一个属性中设置四个过渡属性。 | 3    |
| [transition-property](https://www.runoob.com/cssref/css3-pr-transition-property.html) | 规定应用过渡的 CSS 属性的名称。              | 3    |
| [transition-duration](https://www.runoob.com/cssref/css3-pr-transition-duration.html) | 定义过渡效果花费的时间。默认是 0。           | 3    |
| [transition-timing-function](https://www.runoob.com/cssref/css3-pr-transition-timing-function.html) | 规定过渡效果的时间曲线。默认是 "ease"。      | 3    |
| [transition-delay](https://www.runoob.com/cssref/css3-pr-transition-delay.html) | 规定过渡效果何时开始。默认是 0。             | 3    |



### 动画

要创建 CSS3 动画，你需要了解 **@keyframes** 规则。

**@keyframes** 规则是创建动画。

**@keyframes** 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。

```html
<style> 
div
{
	width:100px;
	height:100px;
	background:red;
	animation:myfirst 1s;
	-webkit-animation:myfirst 1s; /* Safari and Chrome */
}

@keyframes myfirst
{
	from {background:red;}
	to {background:yellow;}
}

@-webkit-keyframes myfirst /* Safari and Chrome */
{
	from {background:red;}
	to {background:yellow;}
}
</style>
```

请用百分比来规定变化发生的时间，或用关键词 "from" 和 "to"，等同于 0% 和 100%。

0% 是动画的开始，100% 是动画的完成。例如：

```css
@keyframes myfirst
{
    0%   {background: red;}
    25%  {background: yellow;}
    50%  {background: blue;}
    100% {background: green;}
}
```

**CSS3的动画属性**

下面的表格列出了 @keyframes 规则和所有动画属性：

| 属性                                                         | 描述                                                         | CSS  |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :--- |
| [@keyframes](https://www.runoob.com/cssref/css3-pr-animation-keyframes.html) | 规定动画。                                                   | 3    |
| [animation](https://www.runoob.com/cssref/css3-pr-animation.html) | 所有动画属性的简写属性。                                     | 3    |
| [animation-name](https://www.runoob.com/cssref/css3-pr-animation-name.html) | 规定 @keyframes 动画的名称。                                 | 3    |
| [animation-duration](https://www.runoob.com/cssref/css3-pr-animation-duration.html) | 规定动画完成一个周期所花费的秒或毫秒。默认是 0。             | 3    |
| [animation-timing-function](https://www.runoob.com/cssref/css3-pr-animation-timing-function.html) | 规定动画的速度曲线。默认是 "ease"。                          | 3    |
| [animation-fill-mode](https://www.runoob.com/cssref/css3-pr-animation-fill-mode.html) | 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。 | 3    |
| [animation-delay](https://www.runoob.com/cssref/css3-pr-animation-delay.html) | 规定动画何时开始。默认是 0。                                 | 3    |
| [animation-iteration-count](https://www.runoob.com/cssref/css3-pr-animation-iteration-count.html) | 规定动画被播放的次数。默认是 1。                             | 3    |
| [animation-direction](https://www.runoob.com/cssref/css3-pr-animation-direction.html) | 规定动画是否在下一周期逆向地播放。默认是 "normal"。          | 3    |
| [animation-play-state](https://www.runoob.com/cssref/css3-pr-animation-play-state.html) | 规定动画是否正在运行或暂停。默认是 "running"。               | 3    |



### 新边框属性

| 属性                                                         | 说明                                           | CSS  |
| :----------------------------------------------------------- | :--------------------------------------------- | :--- |
| [border-image](https://www.runoob.com/cssref/css3-pr-border-image.html) | 设置所有边框图像的速记属性。                   | 3    |
| [border-radius](https://www.runoob.com/cssref/css3-pr-border-radius.html) | 一个用于设置所有四个边框- *-半径属性的速记属性 | 3    |
| [box-shadow](https://www.runoob.com/cssref/css3-pr-box-shadow.html) | 附加一个或多个下拉框的阴影                     | 3    |



### 新的背景属性

| 顺序                                                         | 描述                     | CSS  |
| :----------------------------------------------------------- | :----------------------- | :--- |
| [background-clip](https://www.runoob.com/cssref/css3-pr-background-clip.html) | 规定背景的绘制区域。     | 3    |
| [background-origin](https://www.runoob.com/cssref/css3-pr-background-origin.html) | 规定背景图片的定位区域。 | 3    |
| [background-size](https://www.runoob.com/cssref/css3-pr-background-size.html) | 规定背景图片的尺寸。     | 3    |



### flex布局

下表列出了在弹性盒子中常用到的属性:

| 属性                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [display](https://www.runoob.com/cssref/pr-class-display.html) | 指定 HTML 元素盒子类型。                                     |
| [flex-direction](https://www.runoob.com/cssref/css3-pr-flex-direction.html) | 指定了弹性容器中子元素的排列方式                             |
| [justify-content](https://www.runoob.com/cssref/css3-pr-justify-content.html) | 设置弹性盒子元素在主轴（横轴）方向上的对齐方式。             |
| [align-items](https://www.runoob.com/cssref/css3-pr-align-items.html) | 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。             |
| [flex-wrap](https://www.runoob.com/cssref/css3-pr-flex-wrap.html) | 设置弹性盒子的子元素超出父容器时是否换行。                   |
| [align-content](https://www.runoob.com/cssref/css3-pr-align-content.html) | 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 |
| [flex-flow](https://www.runoob.com/cssref/css3-pr-flex-flow.html) | flex-direction 和 flex-wrap 的简写                           |
| [order](https://www.runoob.com/cssref/css3-pr-order.html)    | 设置弹性盒子的子元素排列顺序。                               |
| [align-self](https://www.runoob.com/cssref/css3-pr-align-self.html) | 在弹性子元素上使用。覆盖容器的 align-items 属性。            |
| [flex](https://www.runoob.com/cssref/css3-pr-flex.html)      | 设置弹性盒子的子元素如何分配空间。                           |

可见 flex 布局十分方便 （推荐）



### 伪元素和伪类

CSS伪元素和伪类是用来添加一些选择器的特殊效果。

**常用CSS伪类/元素**

| 选择器                                                       | 示例           | 示例说明                                        |
| :----------------------------------------------------------- | :------------- | :---------------------------------------------- |
| [:link](https://www.runoob.com/cssref/sel-link.html)         | a:link         | 选择所有未访问链接                              |
| [:visited](https://www.runoob.com/cssref/sel-visited.html)   | a:visited      | 选择所有访问过的链接                            |
| [:active](https://www.runoob.com/cssref/sel-active.html)     | a:active       | 选择正在活动链接                                |
| [:hover](https://www.runoob.com/cssref/sel-hover.html)       | a:hover        | 把鼠标放在链接上的状态                          |
| [:focus](https://www.runoob.com/cssref/sel-focus.html)       | input:focus    | 选择元素输入后具有焦点                          |
| [:first-letter](https://www.runoob.com/cssref/sel-firstletter.html) | p:first-letter | 选择每个<p> 元素的第一个字母                    |
| [:first-line](https://www.runoob.com/cssref/sel-firstline.html) | p:first-line   | 选择每个<p> 元素的第一行                        |
| [:first-child](https://www.runoob.com/cssref/sel-firstchild.html) | p:first-child  | 选择器匹配属于任意元素的第一个子元素的 <p> 元素 |
| [:before](https://www.runoob.com/cssref/sel-before.html)     | p:before       | 在每个<p>元素之前插入内容                       |
| [:after](https://www.runoob.com/cssref/sel-after.html)       | p:after        | 在每个<p>元素之后插入内容                       |
| [:lang(*language*)](https://www.runoob.com/cssref/sel-lang.html) | p:lang(it)     | 为<p>元素的lang属性选择一个开始值               |

示例：

```html
<style>
a:link {color:#000000;}      /* 未访问链接*/
a:visited {color:#00FF00;}  /* 已访问链接 */
a:hover {color:#FF00FF;}  /* 鼠标移动到链接上 */
a:active {color:#0000FF;}  /* 鼠标点击时 */
</style>
```

更多伪类 [点击我](https://www.runoob.com/css/css-pseudo-classes.html)



## JavaScript高级



#### this

面向对象语言中 this 表示当前对象的一个引用。

但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。

- 在方法中，this 表示该方法所属的对象。
- 如果单独使用，this 表示全局对象。
- 在函数中，this 表示全局对象。
- 在函数中，在严格模式下，this 是未定义的(undefined)。
- 在事件中，this 表示接收事件的元素。
- 类似 call() 和 apply() 方法可以将 this 引用到任何对象。

```js
var person = {
  firstName: "John",
  lastName : "Doe",
  id       : 5566,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};
```



**单独使用 this**

单独使用 this，则它指向全局(Global)对象。

在浏览器中，window 就是该全局对象为 [**object Window**]:



**事件中的 this**

```html
<button onclick="this.style.display='none'">点我后我就消失了</button>
```



**显式函数绑定**

在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。

在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, **this** 将指向 person2, 即便它是 person1 的方法：

```html
<body>

<h2>JavaScript this 关键字</h2>
<p>实例中 <strong>this</strong> 指向了 person2，即便它是 person1 的方法:</p>

<p id="demo"></p>

<script>
var person1 = {
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}
var person2 = {
  firstName:"John",
  lastName: "Doe",
}
var x = person1.fullName.call(person2); 
document.getElementById("demo").innerHTML = x; 
</script>
```

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314145949503.png" alt="image-20210314145949503" style="zoom:50%;" />



#### 闭包

私有变量可以用到闭包。如果我们想保护私有变量不受外界干扰，我们可以利用闭包，形成一个不销毁的栈环境。

```html
<script>
var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();
function myFunction(){
    document.getElementById("demo").innerHTML = add();
}
</script>
```

变量 **add** 指定了函数自我调用的返回字值。

自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。

add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。

这个叫作 JavaScript **闭包。**它使得函数拥有私有变量变成可能。

计数器受匿名函数的作用域保护，只能通过 add 方法修改。



#### 函数防抖节流

有时候我们不想让一个函数被无意义地高频调用，这时候我们需要利用函数防抖和节流

##### 防抖

函数防抖：一个需要频繁触发的函数，在规定时间内只让最后一次生效，前面不生效。就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

比如移动端input框输入时，输入结束一定时间后才知道用户输入结束，此时取输入的内容最为合适。

```js
// 函数防抖
var timer = false;
document.getElementById("debounce").onscroll = function(){
	clearTimeout(timer); // 清除未执行的代码，重置回初始化状态

	timer = setTimeout(function(){
		console.log("函数防抖");
	}, 300);
};
```



##### 节流

函数节流：一个函数执行一次后，只有大于设定的时间周期才会执行第二次。

函数节流限制一个函数在一定时间内只能执行一次。

场景：有个需要频繁触发的函数，出于性能优化角度，在规定的时间内，
只让函数触发的第一次生效，后面的不生效。

```js
// 函数节流
var canRun = true;
document.getElementById("throttle").onscroll = function(){
	if(!canRun){
		// 判断是否已空闲，如果在执行中，则直接return
		return;
	}

	canRun = false;
	setTimeout(function(){
		console.log("函数节流");
		canRun = true;
	}, 300);
};
```



#### 事件委托

优点

1 可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒

2 可以实现当新增子对象时无需再次对其绑定（动态绑定事件）

```html
<ul id="myLinks">
  <li id="goSomewhere">Go somewhere</li>
  <li id="doSomething">Do something</li>
  <li id="sayHi">Say hi</li>
</ul>
```

按照传统的做法，需要像下面这样为它们添加 3 个事件处理程序

```js
    var item1 = document.getElementById("goSomewhere");
    var item2 = document.getElementById("doSomething");
    var item3 = document.getElementById("sayHi");
 
    item1.onclick = function() {
      location.href = "http://www.baidu.com";
    };
    item2.onclick = function() {
      document.title = "事件委托";
    };
    item3.onclick = function() {
      alert("hi");
    };
```

如果在一个复杂的 Web 应用程序中，对所有可单击的元素都采用这种方式，那么结果就会有数不 清的代码用于添加事件处理程序。此时，可以利用事件委托技术解决这个问题。使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序，如下面的例子所示

```js
    document.addEventListener("click", function (event) {
      var target = event.target;
      switch (target.id) {
        case "doSomething":
          document.title = "事件委托";
          break;
        case "goSomewhere":
          location.href = "http://www.baidu.com";
          break;
        case "sayHi": alert("hi");
          break;
      }
    })
```

**使用事件委托注意事项**

使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。



#### 事件冒泡

事件冒泡 ：当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到window 。（注意这里传递的仅仅是事件 并不传递所绑定的事件函数。所以如果父级没有绑定事件函数，就算传递了事件 也不会有什么表现 但事件确实传递了。）

阻止事件的冒泡方法，不让事件向documen上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开。

今天来看看前端的冒泡和事件默认事件如何处理

**1.event.stopPropagation()方法**

这是阻止事件的冒泡方法，不让事件向documen上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开，

```js
//阻止冒泡

$(".box1 a").click(function(event){
	event.stopPropagation();
 
    //不会打印1，但是页面会跳转；			
 
});
 
			
$(".box1").click(function(){
	console.log("1")				
});
```

**2.event.preventDefault()方法**

这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；

```js
$(".box1").click(function(){
    console.log("1")；				
});
 
 
$(".box1 a").click(function(event){			
    //阻止默认事件
    event.preventDefault();
 
    //页面不会跳转，但是会打印出1，
})；
```

**3.return false  ；**

这个方法比较暴力，他会同事阻止事件冒泡也会阻止默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()

```js
$(".box1").click(function(){
	console.log("1")				
});	
 
								
$(".box1 a").click(function(event){
	return false;  
    //页面不会跳转，也不会打印出1，等于同时调用了event.stopPropagation()
    //和event.preventDefault()
 
});
```



# AJAX

## 简介

AJAX，即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML）

AJAX 不是新的编程语言，而是一种使用现有标准的新方法。

传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。

AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。

AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。



## AJAX 示例

```html
<script>
function loadXMLDoc()
{
	var xmlhttp;
	if (window.XMLHttpRequest)
	{
		//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
		xmlhttp=new XMLHttpRequest();
	}
	else
	{
		// IE6, IE5 浏览器执行代码
		xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.onreadystatechange=function()
	{
		if (xmlhttp.readyState==4 && xmlhttp.status==200)
		{
			document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
		}
	}
	xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
	xmlhttp.send();
}
</script>
</head>
<body>

<div id="myDiv"><h2>使用 AJAX 修改该文本内容</h2></div>
<button type="button" onclick="loadXMLDoc()">修改内容</button>

</body>
```



## 工作原理

<img src="C:\Users\Ocean\AppData\Roaming\Typora\typora-user-images\image-20210314171209922.png" alt="image-20210314171209922" style="zoom:80%;" />

### 创建 XMLHttpRequest 对象

**XMLHttpRequest** 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。

**创建 XMLHttpRequest 对象的语法：**

```js
variable = new XMLHttpRequest();
```

**老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：**

```js
variable = new ActiveXObject("Microsoft.XMLHTTP");
```

为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：

```js
var xmlhttp;
if (window.XMLHttpRequest)
{
    //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xmlhttp=new XMLHttpRequest();
}
else
{
    // IE6, IE5 浏览器执行代码
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
}
```



### 向服务器发送请求

如需将请求发送到服务器，我们使用 **XMLHttpRequest** 对象的 **open**() 和 **send**() 方法：

```js
xmlhttp.open("GET","ajax_info.txt",true);
xmlhttp.send();
```

| 方法                         | 描述                                                         |
| :--------------------------- | :----------------------------------------------------------- |
| open(*method*,*url*,*async*) | 规定请求的类型、URL 以及是否异步处理请求。*method*：请求的类型；GET 或 POST*url*：文件在服务器上的位置*async*：true（异步）或 false（同步） |
| send(*string*)               | 将请求发送到服务器。*string*：仅用于 POST 请求               |

**GET 还是 POST？**

与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。

然而，在以下情况中，请使用 POST 请求：

- 无法使用缓存文件（更新服务器上的文件或数据库）
- 向服务器发送大量数据（POST 没有数据量限制）
- 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠



**异步 - True 或 False？**

我们建议使用True, 以我个人的理解，在AJAX请求到之前其他应用程序不会挂起或停止，当AJAX请求到后，onreadystatechange 事件会被触发 （异步）

```js
xmlhttp.onreadystatechange=function()
{
    if (xmlhttp.readyState==4 && xmlhttp.status==200)
    {
        document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
    }
}
xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
xmlhttp.send();
```

如果非要使用False也可以，用于一些小请求，但不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面，因为是同步。

```js
xmlhttp.open("GET","/try/ajax/ajax_info.txt",false);
xmlhttp.send();
document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
```



### 服务器响应

如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。

| 属性         | 描述                       |
| :----------- | :------------------------- |
| responseText | 获得字符串形式的响应数据。 |
| responseXML  | 获得 XML 形式的响应数据。  |

如果返回的是字符串形式的，可以直接这样使用。(responseText)

```js
document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
```

如果返回的是XML形式的，则需要把它作为对象进行解析。(responseXML)

```js
xmlDoc = xmlhttp.responseXML;
txt = "";
x = xmlDoc.getElementsByTagName("ARTIST");
for (i = 0;i < x.length; i++)
{
    txt = txt + x[i].childNodes[0].nodeValue + "<br>";
}
document.getElementById("myDiv").innerHTML=txt;
```



### onreadystatechange 事件

每当 readyState 改变时，就会触发 onreadystatechange 事件，下面是 XMLHttpRequest 对象的三个重要的属性：

| 属性               | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| onreadystatechange | 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 |
| readyState         | 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 |
| status             | 200: "OK" 404: 未找到页面                                    |

在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。

当 readyState 等于 4 且状态为 200 时，表示响应已就绪：

```js
xmlhttp.onreadystatechange=function()
{
    if (xmlhttp.readyState==4 && xmlhttp.status==200)
    {
        document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
    }
}
```



如果网站存在多个AJAX任务，可以创建 XMLHttpRequest 对象编写一个*标准*的函数，并为每个 AJAX 任务调用该函数。

该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同）：

```js
function myFunction()
{
    loadXMLDoc("/try/ajax/ajax_info.txt",function()
    {
        if (xmlhttp.readyState==4 && xmlhttp.status==200)
        {
            document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
        }
    });
}
```

